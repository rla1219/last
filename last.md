**앱 관리 런처**
=============

문제점
20대 A씨는 스마트폰에 앱을 30개 가량 다운받았는데 관리하기가 어려웠다. 화면에 있는 앱아이콘을 관리하기가 귀찮다. 자주 사용하지 않는 앱은 어느 페이지에 있는지 몰라 찾기까지 시간이 오래 걸린 것이 한 두번이 아니다. 

**해결방안**
-----------

사용자가 정한 분류 기준에 따라 앱 아이콘에 대한 그룹을 결정하고 결정된 그룹에 따라 앱 아이콘이 표시되도록 제어함으로써 사용자의 입력 없이도 장치 화면에 표시되는 앱 아이콘을 효율적으로 관리하고 그에 따라 사용자의 편의성을 높일 수 있다. 최근 사용빈도수가 낮은 앱은 삭제를 권유하는 메시지를 보낼 수 있다.

**5WHYS**
----------    

   번호  | 문제 | 답  |
-------- | ---- | --- |
1   | 왜 앱을 사용하기가 불편한가? | 앱이 많고 어디에 있는지 찾기 어려워서 |
2   | 왜 앱을 찾기가 어려운가? | 앱들 중에도 필요한 앱과 필요치 않은 앱들이 섞여있어서 |
3   | 왜 앱들이 섞여 있는가? | 사용자가 많은 앱들을 일일이 다 관리하기 귀찮거나 힘들어서 |
4   | 왜 사용자가 관리하기 힘든가? | 쓸모없는 앱들이 많아서 |
5   | 왜 쓸모없는 앱들이 많은가? | 사용자가 삭제하지 않아서 |

**필요성**
---------
스마트폰을 사용하면서 사용자가 필요한 여러 가지 앱들을 다운받아서 사용하는데 사용하고자 하는 앱의 수가 많아서 일일이 관리하기가 어렵다. 또한 화면에 표시되는 앱 아이콘이 제한되어 있어서 한눈에 보기가 어렵다. 
앱 아이콘의 이동 또한 클릭 또는 드래그 터치방식 밖에 없기 때문에 이동시키기 어렵다.
![app](http://blogfiles.naver.net/20160617_147/chanki1007_14661253909919NtAH_PNG/1.PNG)

앱을 사용자가 정한 방식에 의해 정렬할 수 있도록 해야한다.(오른손잡이는 화면의 오른쪽에 앱 아이콘을 정렬)
사용자가 지정하지 않으면 빈도수, 기능별로 묶는다.
사용자 정의에 따라 빈도수가 낮은 앱은 삭제권유 메시지를 보낸다.(한 달에 1회 이하)
아이콘을 길게 누르면 아이콘의 고정 기능, 이동 기능, 삭제 기능, 삭제 권유 불가 기능, 숨기기 기능, 그룹 만들기 기능 등을 선택할 수 있는 창을 띄운다.

**해결책에 대한 아이디어**
---------------------------
- 스마트폰에 초기화된 설정 이외에도 사용자의 정의에 따라 편리한 위치에 볼 수 있어야한다.
- 자주 사용하는 앱들을 우선순위로 볼 수 있게 한다.
- 자주 사용하지 않아 쓸데없이 메모리용량만 차지하는 앱들은 삭제권유를 한다.
- 사람마다 개성이 다른 것과 마찬가지로 이용자마다 사용법이 다름으로 사용자가 정하는 편리한 방법으로 이용해야 한다.

**유사한 문제를 해결한 기존의 방법**
------------------------------------
 * 자주 사용하는 앱은 화면의 가장 위의 줄에 위치한다. 
 * 기능별로 유사한 앱들을 한 파일에 묶어놓는다.
 * 앱 아이콘을 길게 터치하면 편집기능이 있어 간편하게 편집할 수 있다.

**기존 방법에 비해 아이디어의 차별성 및 장점**
-------------------------------------------------
- 사용자가 설정한 방법에 의하여 사용빈도가 가장 높은 앱을 오른쪽에 놓을 수도 있고 왼쪽에 놓을 수도 있게 자유롭다.
- 사용자 인터페이스를 사용자 마음대로 설정할 수 있다. 예를 들어 시계 모양이나 위치, 앱의 배열방법을 자유롭게 할 수 있다.
- 사용빈도가 낮은(한달에 1회 이하) 앱은 삭제 권유를 한다. 
- 아이콘을 길게 누르면 아이콘의 고정 기능, 이동 기능, 삭제 기능, 삭제 권유 불가 기능, 숨기기 기능, 그룹 만들기 기능 등을 선택하여 여러 가지 기능을 사용할 수 있다.

**시스템 구조 설계**
-------------------------
![app](http://postfiles10.naver.net/20160617_121/chanki1007_146612588439444zUG_PNG/2.PNG?type=w3)

> ⦁ 어플리케이션 정보 저장소 : 사용자 설정 데이터를 복사하여 저장하고 어플리케이션을 다운받을 때 정보를 저장한다.

> ⦁ 어플리케이션 분류 제어소 : 
(1) 현재 그룹들의 데이터(고유식별번호)를 갖고 있는 제어소로써, 이 제어소에 데이터가 입력되면 그룹의 기능 데이터들과 입력받은 데이터와 비교하여 입력받은 데이터가 어떤 그룹에 속하는지 알아본다. 후에 입력데이터에 추가적으로 그룹 데이터(식별번호)를 추가시킨 데이터를 전달한다.
(2) 앱의 사용 빈도 데이터가 들어온다면, 앱에 순위를 매긴다. 이 순위 데이터를 전달시킨다. 

> ⦁ 어플리케이션 아이콘 그룹 결정소 : 
(1) 입력받은 데이터를 이용하여 어플리케이션을 그룹에 속하게 하거나 새로운 그룹을 만든다. 입력받은 데이터에 변경사실이 포함된 새로운 데이터를 생성한다. 
(2) 어플리케이션 사용빈도에 대한 순위가 매겨진 데이터를 입력 받으면, 사용자가 설정한 그룹변경 불가 어플리케이션을 포함하여 그룹을 형성한다. 이 형성된 그룹들을 관한 정보를 포함한 데이터를 전달시킨다.

> ⦁ 어플리케이션 관리 제어소 :
(1) 사용자가 설정한 빈도에 관한 데이터를 입력받으면, 한 달 동안에 어플리케이션 사용 빈도를 측정 및 횟수를 저장하여 사용자 설정빈도 데이터와 비교하여 넘어가지 않으면 true, 넘어가면 false 값을 전달한다.
(2) 사용자가 설정한 기간에 관한 데이터를 입력 받으면, 기간 동안에 어플리케이션의 사용 빈도를 측정한다.

> ⦁ 어플리케이션 삭제 관리소 : 입력 데이터가 true이면 사용자에게 삭제 권유를 한다. 사용자가 승낙하면 어플리케이션의 삭제를 수행한다.

> ⦁ 어플리케이션 표시 제어소 : 그룹 데이터를 분석하여 그룹에 속한 어플리케이션들을 시각적으로 보이게 출력한다.


![mobile](http://blogfiles.naver.net/20160617_238/chanki1007_1466125884789jsW4k_PNG/3.PNG)  
 - 그림과 같이 분류 설정을 사용자 정의에 따라 설정되면 자동으로 그림과 같이 분류가 되어집니다. 
 - 그림에서와 같이 틀에 박히지 않은 앱 (카카오톡)배열을 설정할 수 있게 만들 수 있다.


![mobile2](http://blogfiles.naver.net/20160617_262/chanki1007_1466125885446x2VIL_PNG/4.PNG)
![mobile3](http://blogfiles.naver.net/20160617_103/chanki1007_1466125885754XAv8s_PNG/5.PNG)
![mobile4](http://blogfiles.naver.net/20160617_103/chanki1007_1466125885754XAv8s_PNG/6.PNG)

 - 위 3개의 그림을 보듯이, 페이스북, 앱다이어트 중에 실행한 빈도 수가 높으므로 가장 윗 줄에 앱이 배정되어진다. 그리고 V3 Mobile, 태그, 일정 등등 1개월 동안 사용되지 않는 앱은 사용자는 삭제 권유를 받는다. 하지만 Flash Player Settings과 같이 문서 앱은 자주 사용되어지지 않아도 삭제하면 안되므로 사용자 정의에 따라 삭제권유를 하지 않게 만들 수도 있다. 
아이콘을 길게 누르면 아이콘의 고정 기능, 이동 기능, 삭제 기능, 삭제 권유 불가 기능, 숨기기 기능, 그룹 만들기 기능 등을 선택하여 여러 가지 기능을 사용할 수 있다. 또한 아이콘을 자유롭게 회전, 크기조정을 하여 사용자의 편의에 따라 설정할 수 있다.

> ### **_시스템 설계_**  
> - 시스템 목적 : 스마트폰 사용자가 원하는 대로 어플리케이션을 운용하여 편리성을 향상하는 것에 목적을 두고 있다.
> - 시스템 구조 
> - 시스템 기능 
> - 시스템 구성 요소 및 기능, 입출력데이터 
> - 시스템 동작흐름 

시스템 기능
-----------

      문제 |
 ---|
  1. 어플리케이션을 다운받으면 자동으로 분류가 되고 그룹에 속해지거나 또는 그룹 생성된다.|
  2. 빈도수가 낮은 어플리케이션은 사용자에게 삭제 권유를 하게 한다. 삭제 동의 시 삭제한다.  | 
  3. 빈도 수 기준에 따라 자동으로 어플리케이션이 분류된다. | 
  4. 어플리케이션 표시를 정해진 틀에 벗어나 사용자가 지정한 위치에 설정할 수 있다. | 
  

##### 1번 기능 모듈 

어플리케이션을 다운받으면 자동으로 분류가 되고 그룹에 속해지거나 또는 그룹 생성된다.

![module1](http://postfiles5.naver.net/20160617_276/chanki1007_14661274883552fFER_PNG/manage.PNG?type=w3) 

  ● 어플리케이션 정보 저장소 |
 -----------------------------------------------------------------------------|
입력 데이터 : 어플리케이션 정보. |
정보 저장소 기능 : 입력받은 어플리케이션의 정보를 복사하고 저장한다. |
출력 데이터 : 다른 저장소에서 호출 시 복사한 어플리케이션 정보를 보내준다. |
 
 
![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)

● 어플리케이션 분류 제어소  |
 -----------------------------------------------------------------------------|
입력 데이터 : 정보 저장소에서 나온 어플리케이션 정보 데이터 |
분류 제어소 기능 : 현재 각각 폴더의 분류 기준 데이터를 가지고 있는 제어소로써, 입력 데이터가 어떤 범위에 속하는지, 속하지 않는지에 대하여 알아보고 이걸 데이터화 하는 기능을 수행한다. |
출력 데이터 : 분류 데이터 |

![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)


● 어플리케이션 아이콘 그룹 제어소       |
 -----------------------------------------------------------------------------|
입력 데이터 : 분류 제어소에서 나온 분류 데이터 |
아이콘 그룹 제어소 기능 : 분류 데이터를 이용하여 어플리케이션은 새로운 그룹을 생성하거나 기존에 있는 그룹에 포함시킨다.  그리고 변경사실이 포함된 새로운 그룹 데이터를 생성한다. |
출력 데이터 : 다운받은 어플리케이션의 데이터를 포함한 새로운 그룹데이터 |

![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)


● 어플리케이션 표시 제어소         |
 -----------------------------------------------------------------------------|
입력 데이터 : 아이콘 그룹 제어소에서 나온 그룹 데이터 |
표시 제어소 기능 : 그룹 데이터를 분석하여 최종적으로 이 어플리케이션 어디에 속했는지 알아보고 그 그룹 또는 폴더에 출력을 하여 시각적으로 보여준다.|
출력 데이터 : 다운받은 어플리케이션의 데이터를 포함한 새로운 그룹데이터 |

![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)

● 어플리케이션 관리 제어소           |
 -----------------------------------------------------------------------------|
입력 데이터 : 그룹 데이터 |
관리 제어소 기능 : 각각 어플리케이션을 지속적으로 관리 및 다른 제어소에서 필요시에 그룹에 대한 데이터를 출력해준다.|

```C++
struct save(string down) {
  string name[100];
  double size;
  int fre;
  string date[8];
  int datanum;
  datanum[50] = group(appinfor);
  string del;
  int userfreq;
};

//처음 앱 다운시 저장소에 저장

void save(string down){
  struct save num[100];
  static int i = 0;
  
  num[i].name = down.name;
  num[i].date[8] = down.name;
  i++;
}

// 어플리케이션 사용시 사용빈도 증가

int fre(int& fre){
  fre++;
}

//기능을 데이터화

int group(string appinfor){
  string appinfor;
  if(strcmp(appinfor,사진) == 0 ) {
    int i = 1 ;  }
  if(strcmp(appinfor,동영상) == 0 ) {
    int i = 2 ;  }
  if(strcmp(appinfor,금융) == 0 ) {
    int i = 3 ;  }
  return i;
}

//같은 그룹에 넣을지 말지 정하는 함수

void icon(int exist_group, int datanum) {
  if(exist_group_datanum == datanum)  {  // 데이터가 그룹데이터와 같다면 
    if(question()) { equalprint(); } // 같은 그룹에 속할지 안할지 물어본다.
  }
}

void print(icon_print) {
  print_screen_icon();
}
```

##### 2번 기능모듈

빈도수가 낮은 어플리케이션은 사용자에게 삭제 권유를 하게 한다. 승낙 시 삭제를 실행한다.

![module2](http://postfiles3.naver.net/20160617_66/chanki1007_1466129203147VH4Ks_PNG/m1.PNG?type=w3)

● 어플리케이션 정보 저장소          |
 -----------------------------------------------------------------------------|
입력 데이터 : 사용자 설정의 데이터 |
정보 저장소 기능 : 사용자 설정의 데이터를 복사하여 저장한다. 이 기능에서는 설정 데이터 중에 빈도 설정 데이터를 출력한다.  |
출력 데이터 : 빈도 설정 데이터 |

![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)


● 어플리케이션 관리 제어소         |
 -----------------------------------------------------------------------------|
입력 데이터 : 빈도 설정 데이터 |
관리 제어소 기능 : 한 달 동안의 어플리케이션 사용 빈도를 측정 및 횟수를 저장하고 사용자에게 입력받은 빈도 설정 데이터와 비교하여 설정 빈도 수치를 넘어가지 않으면 true 또는 넘어가면 false 값을 출력한다. |
출력 데이터 : true 또는 false |

![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)


● 어플리케이션 삭제 제어소         |
 -----------------------------------------------------------------------------|
입력 데이터 : true 또는 false |
삭제 제어소 기능 : 입력 데이터가 true이면 사용자에게 삭제권유를 한다. 만약 사용자가 승낙할 시 어플리케이션을 삭제한다. |

```C++
int saveData() { // 사용자가 빈도수를 설정
  int userFrequency;
  cin >> userFrequency;
  
  return userFrequency;
}

int manage() { // 앱이 실행되면 앱의 사용횟수 증가
  int appFrequency;
  bool apptouch;
  
  if(apptouch == 1) {
    appFrequency++;
  }
  
  return appFrequency;
}
void main() {
  bool appaDelete;
  char decision;
  int userFrequency;
  int appFrequency;
  
  userFrequency = saveData();
  appFrequency = manage();
  if(userFrequency > appFrequency) { // 앱의 사용횟수가 사용자가 설정한 빈도수보다 작으면 삭제 권유
    cout << "사용빈도수가 낮습니다. 삭제하시겠습니까? (Y/N)\n";
    cin >> decision;
  
    if(decision = 'y' || 'Y' ) { // 사용자가 삭제를 원할시 삭제
      appDelete = true;
    }
    else if(decision = 'n' || 'N' ) { // 원하지 않으면 보류
      appDelete =false;
    }
  }
  else if(userFrequency <= appFrequency) {
    appDelete = false;
  }
}
```

##### 3번 기능모듈

빈도수 기준에 따라 자동으로 어플리케이션이 분류된다.

![module](http://postfiles9.naver.net/20160617_8/chanki1007_1466129867830PK65c_PNG/module3.PNG?type=w3)

● 어플리케이션 정보 저장소          |
 -----------------------------------------------------------------------------|
입력 데이터 : 사용자 설정의 데이터 |
정보 저장소 기능 : 사용자 설정의 데이터를 복사하여 저장한다. 이 기능에서는 사용 빈도수를 며칠마다 측정하는지에 대한 빈도 설정 데이터를 출력한다. 또한 사용빈도와 관계없이 사용자가 원하는 폴더에 어플리케이션을 고정시키는 const 데이터도 입력을 받는다.  |
출력 데이터 : 설정한 기간 데이터, const 데이터 |


![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)


● 어플리케이션 관리 제어소          |
 -----------------------------------------------------------------------------|
입력 데이터 : 기간 설정 데이터 |
관리 제어소 기능 : 기간 설정 데이터에서 설정된 기간 동안에 각 어플리케이션의 사용 빈도를 측정한다.  |
출력 데이터 : 기간 동안에 각 어플리케이션 사용 빈도 데이터 |

![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)


● 어플리케이션 분류 제어소         |
 -----------------------------------------------------------------------------|
입력 데이터 : 어플리케이션 각각의 사용 빈도 데이터 |
분류 제어소 기능 : 어플리케이션의 각각 사용 빈도를 가지고 많이 사용된 순서대로 순위를 매긴다. 순위가 매겨지면 이것을 데이터화 한다. |
출력 데이터 : 사용 빈도에 따라 순위가 매겨진 데이터 |

![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)

● 어플리케이션 아이콘 그룹 제어소          |
 -----------------------------------------------------------------------------|
입력 데이터 : 어플리케이션의 순위가 매겨진 데이터 |
아이콘 그룹 제어소 기능 : 처음에 사용자가 지정한 위치 고정 어플리케이션 있을 경우, 해당 위치를 포함한 그룹에 먼저 고정 어플리케이션을 포함시킨다. 그리고 입력받은 순위 데이터에서 순서대로 어플리케이션을 이용하여 그룹을 형성한다. 형성된 그룹들의 정보를 포함한 데이터를 생성한다. |
출력 데이터 :  새롭게 생성된 그룹 데이터 |

![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)


● 어플리케이션 표시 제어소         |
 -----------------------------------------------------------------------------|
입력 데이터 : 새롭게 생성된 그룹 데이터 |
표시 제어소 기능 : 입력받은 그룹 데이터를 분석하여 어떤 어플리케이션이 이 그룹에 속했는지 알아보고 시각적으로 보여준다. |

```C++
// 지속적으로 사용빈도 측정
void fre() {
  for(int i = 1 ; i > apllappnum ; i++) {
  if(today - num[i].date == usersetting) {
    if(freg() >= userfreg()) {
      num[i].del = false;
      }
    }
  }
}
void rank_fre() {
//정보 저장소에서 가져온 값 사용 빈도대로 순서를 나열
  for(int i = 1; i>allappnum; i++) {
    calling(i);
    fre = new int [allnum];
    rank();
   }
 }
 void groupp() { // 유저세팅이 있을 경우 랭크그룹에 순위권으로 넣어둔다.
   usersetting() -> rankgroup() ;
}

//랭크그룹을 토대로 화면에 표시
void printf() {
  rankgroup -> print() ;
}
```

##### 4번 기능모듈

어플리케이션 표시를 정해진 틀에 벗어나 사용자가 지정한 위치에 설정할 수 있다.

![module4](http://postfiles10.naver.net/20160617_25/chanki1007_1466129868044s18oP_PNG/module4.PNG?type=w3)

● 어플리케이션 관리 제어소           |
 -----------------------------------------------------------------------------|
입력 데이터 : 사용자 지정한 위치(드래그)  |
관리 제어소 기능 : 사용자가 지정한 위치를 2차원 평면 그래프로 옮긴다. 사용자가 지정한 위치를 x값, y값으로 치환하여 데이터화 한다. |
출력 데이터 : 사용자가 지정한 위치( x , y ) 데이터 |


![direction](http://postfiles5.naver.net/20160617_228/chanki1007_1466127488007UUblA_PNG/q.PNG?type=w3)


● 어플리케이션 표시 제어소        |
 -----------------------------------------------------------------------------|
입력 데이터 : 사용자가 지정한 위치( x , y ) 데이터 |
표시 제어소 기능 : 지정한 위치에 어플리케이션이 옮겨지고 시각적으로 보이게 한다. |

```C++
int coordinate() {
  double x, y;
  
  cin >> x >> y; // 사용자가 지정하는 위치입력
  cout << icon_image; // 그 위치에 아이콘을 표시
}
```

**과제 수행 내용에 대한 각자 의견 및 소감**

김영재 : 어떤 불편한 문제를 해결할 때, 어떻게 접근하는지 알게 되었고 팀 협력을 통해서 다양한 해결방법의 존재를 느낄 수 있었다.


김용규 : 이번 과제를 통하여 아이디어에 대해서 팀원 모두가 그것에 대해 몰두하면서 같이 생각을 나누고 토론할 수 있어서 뿌듯한 과제였다. 특히 아이디어를 구현시킬 때 가장 힘들었는데 아직 런처를 만드는 것까지 아니 안드로이드 앱을 만드는 것도 몰라서 어려움을 많이 겪었다. 팀원을 서로 의지해서 어려움을 해결한 것 같아서 좋은 결과물이 나온 것 같다.


김찬기 : 문제점 해결을 위해 아이디어를 도출하고 기존의 방법이 있으면 그것을 조사하여 우리가 생각한 것과 다른 것이 무엇인지 알아가며 ‘기존의 방법보다 우리가 더 우수한 아이디어를 낼 수 있구나.’하고 자신감을 얻었습니다. 또한 시스템 구조 상세 설계를 하며 막연하게 생각했던 아이디어를 구체화하면서 시스템 구성의 흐름을 자세하게 알게 되었고 그에 따른 간단한 코딩을 해보며 완벽하지는 않지만 기능에 맞게 함수를 구현하였습니다. 이렇게 직접 시스템을 구상하고 코딩을 해본 것이 처음이어서 낯설고 힘들었지만 좋은 경험이었습니다.
